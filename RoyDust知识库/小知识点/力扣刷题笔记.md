## **异或运算的性质：**

异或运算是基于二进制的位运算，采用符号XOR或者^来表示，运算规则是就与二进制，如果是同值取0、异值取1。

简单的理解就是不进位加法，例如1+1=0，0+0=0，1+0=0；

性质：

1. 交换律 可以任意交换运算因子，结果不变。
2. 结合律 （a^b）^c=a^(a^c)
3. 对于任何数x，都有x^x=0,x^0=x,同自己求异或运算为0，同0求异或运算结果为自己
4. 自反性，A^B^B=A^0=A。这个性质可以用来求哪一个数为一个

用法实例：

**例一：在不引入第三个变量的情况下，两个变量的值（整数）**

```java
//交换a、b的值
a=a^b
b=a^b
a=a^b
```

**例二：判断奇数偶数更简单更高效的做法**

```text
//这个实际考的不多， 太简单
//思路：奇数的二进制最低为一定为1，偶数的二进制最低位一定为0，
a^1==1?偶数：奇数
```

**例三：找出唯一一个成对的数**

> **题干：**1-1000这1000个数放在含有1001个元素的数组中，只有唯一的一个元素值重复，其它均只出现 一次。每个数组元素只能访问一次，设计一个算法，将它找出来；不用辅助存储空 间，能否设计一个算法实现？

第一种解题思路：将所有的数加起来减去（1+2+……+1000）。但是这个有可能导致内存溢出

```text
//第二种思路：
将所有的值异或运算，结果再与（1^2^3……^1000）异或运算
结果相当于（1^1^2^2……1000^1000^k）最终的结果就是k
```

**例题五：找出唯一落单的那个数字（也就是仅仅出现一次的那个数）**

```text
结果=a[0]^a[1]^...^a[n-1]
```

**例题：**

存在重复元素
给定一个整数数组，判断是否存在重复元素。

如果存在一值在数组中出现至少两次，函数返回 true 。如果数组中每个元素都不相同，则返回 false 。 

> 示例 1:
>
> 输入: [1,2,3,1]
> 输出: true
>
> 示例 2:
>
> 输入: [1,2,3,4]
> 输出: false
>
> 示例 3:
>
> 输入: [1,1,1,3,3,4,3,2,4,2]
> 输出: true

```java
import java.util.Arrays;

class Solution {
    public boolean containsDuplicate(int[] nums) {
        Arrays.sort(nums);
        for (int i = 0; i < nums.length-1; i++) {
            if(nums[i] == nums[i+1]){
                return true;
            }
        }
        return false;
    }
}
```

## 有效的数独

请你判断一个 9x9 的数独是否有效。只需要 根据以下规则 ，验证已经填入的数字是否有效即可。

数字 1-9 在每一行只能出现一次。
数字 1-9 在每一列只能出现一次。
数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。（请参考示例图）
数独部分空格内已填入了数字，空白格用 '.' 表示。

注意：

一个有效的数独（部分已被填充）不一定是可解的。
只需要根据以上规则，验证已经填入的数字是否有效即可。


示例 1：

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/04/12/250px-sudoku-by-l2g-20050714svg.png)

```
输入：board = 
[["5","3",".",".","7",".",".",".","."]
,["6",".",".","1","9","5",".",".","."]
,[".","9","8",".",".",".",".","6","."]
,["8",".",".",".","6",".",".",".","3"]
,["4",".",".","8",".","3",".",".","1"]
,["7",".",".",".","2",".",".",".","6"]
,[".","6",".",".",".",".","2","8","."]
,[".",".",".","4","1","9",".",".","5"]
,[".",".",".",".","8",".",".","7","9"]]
输出：true
```

**示例 2：**

```
输入：board = 
[["8","3",".",".","7",".",".",".","."]
,["6",".",".","1","9","5",".",".","."]
,[".","9","8",".",".",".",".","6","."]
,["8",".",".",".","6",".",".",".","3"]
,["4",".",".","8",".","3",".",".","1"]
,["7",".",".",".","2",".",".",".","6"]
,[".","6",".",".",".",".","2","8","."]
,[".",".",".","4","1","9",".",".","5"]
,[".",".",".",".","8",".",".","7","9"]]
输出：false
解释：除了第一行的第一个数字从 5 改为 8 以外，空格内其他数字均与 示例1 相同。 但由于位于左上角的 3x3 宫内有两个 8 存在, 因此这个数独是无效的。
```



1. 使用`3 * (i / 3) + j / 3` (  **i代表行的增加、j代表列的增加** ) 就可以根据当前的行列关系计算出当前处于第几个方阵
2. 使用``Boolean[][]`来存储行列的的数字
3. 如果是第一次遇到该数字就会`row[j][temp] = true`让他在该行、列、方阵里为true
4. 如果是第二次遇到该数字就会返回false
5. 如果遍历全部都没有重复的就返回true

```java
class Solution {
    public boolean isValidSudoku(char[][] board) {
        int length = board.length;
        boolean[][] row = new boolean[length][length+1];
        boolean[][] col = new boolean[length][length+1];
        boolean[][] cell = new boolean[length][length+1];
        for (int i = 0; i < length; i++) {
            for (int j = 0; j < length; j++) {
                int index = i / 3 * 3 + j / 3;
                if (board[i][j] == '.') {
                    continue;
                } else {
                    int temp = board[i][j] - '0';
                    if (row[j][temp]) return false;
                    else row[j][temp] = true;
                    if (col[i][temp]) return false;
                    else col[i][temp] = true;
                    if (cell[index][temp]) return false;
                    else cell[index][temp] = true;
                }
            }
        }
        return true;
    }
}
```

## 字符串中的第一个唯一字符

给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。

 

**示例：**

```java
class Solution {
    public int firstUniqChar(String s) {
        char[] str = s.toCharArray();
        int[] count = new int[26];
        for (int i = 0; i < str.length; i++) {
            count[str[i] - 'a']++;
        }
        for (int i = 0; i < str.length; i++) {
            if (count[str[i] - 'a'] == 1){
                return i;
            }
        }
        return -1;
    }
}
```



思路：

1. 将字符串转数组
2. 设置一个字母表，将字符串数组遍历，记录出现的字母
3. 再次遍历字符串数组，找到只出现一次的字母



## 最长公共前缀

编写一个函数来查找字符串数组中的最长公共前缀。

如果不存在公共前缀，返回空字符串 `""`。

 

**示例 1：**

```java
输入：strs = ["flower","flow","flight"]
输出："fl"
```

**示例 2：**

```java
输入：strs = ["dog","racecar","car"]
输出：""
解释：输入不存在公共前缀。
```

## 输出小数点后几位数

```java
System.out.println(String.format("%.2f",a);
```

